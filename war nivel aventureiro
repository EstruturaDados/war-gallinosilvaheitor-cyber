#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define TAM_NOME 30
#define TAM_COR 10

// Definição da struct Territorio
typedef struct {
    char nome[TAM_NOME];
    char cor[TAM_COR];
    int tropas;
} Territorio;

// Função para cadastrar os territórios
void cadastrarTerritorios(Territorio* mapa, int qtd) {
    for (int i = 0; i < qtd; i++) {
        printf("\n--- Cadastro do Território %d ---\n", i + 1);
        printf("Nome do território: ");
        fgets(mapa[i].nome, TAM_NOME, stdin);
        mapa[i].nome[strcspn(mapa[i].nome, "\n")] = '\0'; // remove '\n'

        printf("Cor do exército: ");
        fgets(mapa[i].cor, TAM_COR, stdin);
        mapa[i].cor[strcspn(mapa[i].cor, "\n")] = '\0';

        printf("Número de tropas: ");
        scanf("%d", &mapa[i].tropas);
        while (getchar() != '\n'); // limpa buffer
    }
}

// Função para exibir todos os territórios
void exibirTerritorios(Territorio* mapa, int qtd) {
    printf("\n======= TERRITÓRIOS =======\n");
    for (int i = 0; i < qtd; i++) {
        printf("Território %d:\n", i);
        printf("  Nome  : %s\n", mapa[i].nome);
        printf("  Cor   : %s\n", mapa[i].cor);
        printf("  Tropas: %d\n", mapa[i].tropas);
    }
    printf("===========================\n");
}

// Função de ataque entre dois territórios
void atacar(Territorio* atacante, Territorio* defensor) {
    if (strcmp(atacante->cor, defensor->cor) == 0) {
        printf("\n[!] Ataque inválido: os territórios pertencem ao mesmo exército.\n");
        return;
    }

    if (atacante->tropas < 2) {
        printf("\n[!] Tropas insuficientes para atacar (mínimo 2 tropas).\n");
        return;
    }

    int dadoAtacante = rand() % 6 + 1; // 1 a 6
    int dadoDefensor = rand() % 6 + 1;

    printf("\nRolando os dados...\n");
    printf("Dado do atacante: %d\n", dadoAtacante);
    printf("Dado do defensor: %d\n", dadoDefensor);

    if (dadoAtacante > dadoDefensor) {
        printf("\n>> Vitória do atacante!\n");

        // Troca de cor e tropas do defensor
        strcpy(defensor->cor, atacante->cor);
        defensor->tropas = atacante->tropas / 2;

        // Reduz as tropas do atacante
        atacante->tropas -= defensor->tropas;

        printf("[INFO] O território %s foi conquistado!\n", defensor->nome);
    } else {
        printf("\n>> Defesa bem-sucedida!\n");

        // Atacante perde 1 tropa
        atacante->tropas -= 1;
        if (atacante->tropas < 0)
            atacante->tropas = 0;

        printf("[INFO] O território %s resistiu ao ataque.\n", defensor->nome);
    }
}

// Função para liberar a memória alocada
void liberarMemoria(Territorio* mapa) {
    free(mapa);
    printf("\n[INFO] Memória liberada com sucesso.\n");
}

// Função principal
int main() {
    srand(time(NULL)); // Garante aleatoriedade

    int qtdTerritorios;
    printf("Digite o número de territórios: ");
    scanf("%d", &qtdTerritorios);
    while (getchar() != '\n'); // limpa buffer

    // Alocação dinâmica do vetor de territórios
    Territorio* mapa = (Territorio*) malloc(qtdTerritorios * sizeof(Territorio));
    if (mapa == NULL) {
        printf("Erro ao alocar memória.\n");
        return 1;
    }

    // Cadastro inicial
    cadastrarTerritorios(mapa, qtdTerritorios);

    int opcao;
    do {
        printf("\n====== MENU ======\n");
        printf("1 - Exibir territórios\n");
        printf("2 - Atacar território\n");
        printf("0 - Sair\n");
        printf("Escolha uma opção: ");
        scanf("%d", &opcao);
        while (getchar() != '\n'); // limpa buffer

        switch (opcao) {
            case 1:
                exibirTerritorios(mapa, qtdTerritorios);
                break;

            case 2: {
                int iAtacante, iDefensor;

                exibirTerritorios(mapa, qtdTerritorios);
                printf("\nInforme o número do território atacante: ");
                scanf("%d", &iAtacante);
                printf("Informe o número do território defensor: ");
                scanf("%d", &iDefensor);
                while (getchar() != '\n');

                if (iAtacante >= 0 && iAtacante < qtdTerritorios &&
                    iDefensor >= 0 && iDefensor < qtdTerritorios) {
                    atacar(&mapa[iAtacante], &mapa[iDefensor]);
                } else {
                    printf("\n[!] Índices inválidos.\n");
                }

                break;
            }

            case 0:
                printf("Encerrando o programa...\n");
                break;

            default:
                printf("Opção inválida. Tente novamente.\n");
        }

    } while (opcao != 0);

    liberarMemoria(mapa);
    return 0;
}
